# Это небольшая шпаргалка для Backend
Сюда будет добавляться вновь изученный мною материал для запомниания и своевременного добавления.
Материал будет поделен на несколько частей которые будут выглядеть так:

1. Сеть (протоколы и как все это работает)

2. Приложения(для работы с беком)

3. Язык GO(основы, конкуретнсоть, библиотеки)


# TO-DO

* Добавить оглавление

* Добавить раздел Приложения(Kafka, Reddis, MongoDB RabbitMQ)

* Добавить раздел язык GO (основы, конкуретнсоть, библиотеки)

* OpenAPI 3

* CI/CD

* SOLID

* Grafana и Prometeus


## Сеть 

### HTTP/HTTPS
**HTTP (HyperText Transfer Protocol, «протокол передачи гипертекста»)** — протокол прикладного уровня для обмена данными между клиентом и сервером в интернете.
Раньше данный протокол использоватлся для передачи как это можно понять Гипертекста:) но теперь через него можно передавть множество других вещей(картинки, текст, аудио)

Основные характеристики это остуствие состояний, то есть запрос должен быть полный, со всей необходимой информацией, а также 
используется модель Request - Response. То есть клиент иницализирует запрос , сервер ждет запросы и после получения
возваращет ответ.

**Банда HTTP запроса**
1. Стартовая строка (Request line) :
    - Метод (HTTP verb) Вот основные: GET(получить), POST(отправить/создать), PUT(обновить), DELETE(удалить)

    - Путь(Path): URL-адрес ресурса 

    - Версия HTTP
2. Заголовки(Headers) 
    Это мета инофрмация о запросе такая как:
    - HOST - какой сайт запрашивается
    - Uset-agent - инфрмация о браузере и ОС клиента
    - Accept какие типы данных клиент понимает
    - Authorization тоекн для авторизации к защищенным ресурсам
    - Content Type если есть тело запроса то какой в нем тип данных

3. Тело запроса(Body)
    Необезательная часть, существует у методов PUT/POST
    Выглядит как файл с информацией о пользователе

**Ответ http запроса**

1. Код состояния (Status Code):
Может содержать в себе трехзначный код который подразделяетс на типы:

- 1ХХ это информационные коды

- 2ХХ коды успеха

- 3ХХ коды перенаправления, сообщают пользователю что необходимо сделать другой запрос для правильного результат

- 4ХХ коды указывающие на ошибку клиента

- 5ХХ коды указывающие на ошибку сервера

Вот самые популярные 

200 OK — успех.

201 Created — ресурс создан.

400 Bad Request — неверный запрос от клиента.

401 Unauthorized — требуется аутентификация.

404 Not Found — ресурс не найден.

500 Internal Server Error — ошибка на сервере.

2. Заголовки(Headers)
Примерно похожая мето информация об ответе, какие данны есть в ответе, инструкции по кешированию или команды браузеру.

3. Тело(Body)
    Содержит данные в выбранном формает, если данные вообще имеются.

**HTTPS** - Такой же протокол только с припиской S, что означает security. Данный протокол поддерживает  шифрование соединений  
по технологии SSL/TLS

Работает так:
Перед началом передачи данных осуществляет так называемый Handshake(рукопожатие). Сервер отправляет свой SSL сертефикат который подтверждает что это именно тот сервер который нужен. Если все прошло успешно, сервер с помощью публичного ключа из сертефиката шифрует свой ключ  и отправляет его. После чего начинается обмен данными.


### Протоколы TCP и UDP 
**TCP (Transmission Control Protocol)**  и  **UDP (User Datagram Protocol)** - Основные транспортные протоколы , отвечающие за доставку данных между приложениями на разных хостах. 

**Работают на 4-ом транспортном уровне модели OSI**

**Главное отличиие:** ТСP работает более точно и гаранитрует полный пакет данных. В то время как UDP обеспечивает более быструю доставку но не дает гарнитий. 

##### Основыне моменты TCP

* Гарантирует доставку данных без ошибок 

* Испольузет _трех этапное_ рукопожатие для установки надежного соединения.

* контролиурет скорость потока чтобы не перегрузить получателя 

* Нумерует пакеты

* Даннные могут передаватсья в обоих направлениях благодрая _дуплексному_ соединению 

* Заголовок большой и содержит большое количество управляющей информации

* Обычно применяется в Веб-браузинге (HTTP/HTTPS), электронная почта , передача файлов, **там где важна точность**

##### Основыне моменты UDP

* Не гарантиурет доставку пакетов , потерянные пакеты не дублируются 

* не устанавливает предварительного соединения 

* Не контрлирует поток 

* Пакеты не нумеруются 

* Заголовок максимально простой: порты источника/назначения, длина , контрольная сумма.

* Обычно применяется в видео - аудио стримингах, DNS запросы, системы реального времени.  **Там где важна скорость и маленькие задержки**
 
### IPv4, IPv6 

**IPv4, IPv6** - Основные пртоколы сетевого уровня (3-ий уровень  OSI), отвечающие за адрессацию устройств и маршрутизацию пакетов. В общем регулируют как устройства будут индефициоваться в сети и как данные будут находить путь от отправителя к получателю.

**IPv4** - давно всем знакомый __Internet Protocol version 4__ , представляет из себя 4 числа разделенные точками, каждое из которых не превышает 255. Из основго можно выделить что вариативность такого рода адрессов уже закочиллась и приходиться использовать **NAT(Network Adress Translation)**, такая система позволяет множеству устройств в локальной сети(с приватными адрессами), выходить в интернет через один публичный IP-адресс роутера. Также отсутвстие базовой безопасности , и не очень эффективная маршуртизация из-за заголовка. 

**IPv6** - Такой же протокол только 6 версии. Записывается как восемь групп  четырех шестнадцатиричных цифр, разделенных двоеточием. Пример *2001:0db8:85a3:0000:0000:8a2e:0370:7334* , ведущеие нули можно сократить на *::* один  раз в адрессе *2001:0db8:85a3::8a2e:0370:7334*. Из преимуществ, это огромное адрессное пространство. Также возможна автоконфигурация адресса. Упрощенный заголовок облегачающий маршрутизацию и еще только отправитель может фрагментировать пакет , что тоже облегчает работу маршрутизатора. Встроенная безопасность IPsec. Существует эффективная адрессаная рассылка. 

Как итог фундаментов всего интернета явялется **IPv4**, но  **IPv6** явялестя будущем интернета из-за большого количетсва возможных адрессов , и большого функционала представленого на старте.

### Порты

Теперь можно перейти к DNS, но пережде чем о нем поговорить следует рассказать немного о портах. 

**Порт** в компьютере - это такого рода логические двери. Если приводить пример то и если бы IP-адресс был адрессом дома, а порт это номер конкретной квартиры в этом доме. _Главная задача портов это позволить компьютеру работать одновременно с несколькими сетевыми сервисами_

Существует от **0 до 65535** разных портов, распределяются они таким образом:

* 0-1023 Системные порты, зарезервированы для важных сервисов.(требуют прав администратора)

* 1024-49151 Порты для популярных приложений (Регестрируются IANA)

* 49152 - 65535 Кратковременные порты для клиентских программ

Каждый порт относится к конретному транспортному протоколу, если вы посмотрите немного выше, вы поймете что за траспрныте протколы.

##### Как это работает ???

1. Программа/сервер открывают один из портов и начанают слушать. 

2. Когда вы заходите на сервер или по определенному адресу. 

3. Ваш браузер узнает IP адресс через DNS. 

4. Случайно выбирает свободный порт на компьютере и отправляет запрос на IP сервера на порт который был открыт севрером или программой.

5. После чего ответ придет именно на открытй порт на вашем компьютере, это сделает за вас браузер.

Посмотерть открытые порты можно с помощью таких команд:

* На windows
``` bash
netstat -ano
```

* На Linux
``` bash
ss -tuln  # или netstat -tuln
```

Последняя очень **важная** вещь, это безопасность. Открытые неиспользуемые порты являются большое уязвимостью. В связи с этим порты нужно закрывать или использовать защитные сервисы , такие как   брандмауэр.

### DNS

**DNS (Domain Name System)** - это расперделнная система которая преобразовывает доменные имена в IP-адресс и наооборот. Грубо говоря вы всегда заходите на *yandex.ru* ,но компьютер это видит не так , а как IP адресс, чтобы он мог связаться с этим сервером. Если что для yandex.ru IP будет - 77.88.55.88.

Из плюсов DNS это во первых проще для пользователей, во вторых DNS позволяет менять адресс вне зависимости от домена, а также может возвращать разные адресса для распределения трафика. 

##### DNS работает таким образом:

1. Пользователь вводит какой то домен. 

2. Браузер проверяет локальный кеш(вдруг этот домен недавно искали)

3. ОС проверяет свой кеш и файл hosts

4. Если ничего не найдено происходит запрос к резолверу. (Обычно это сервер провайдера или публичные резолверы). Резолвер ищет запрос в своем кеше, если не находит, начинает рекурсивный запрос. 

5. Рекурсия 
   Резолвер спрашивает корневые DNS-серверы (13 групп по всему миру)
   Корневые серверы отвечают адресами TLD-серверов (Top-Level Domain)
   Резолвер спрашивает TLD-серверы
   TLD-серверы возвращают адреса авторитативных DNS-серверов домена

6. Авторитативные серверы: 
    Резолвер спрашивает их какой Ip адресс у домена который ввел пользователь. В ответ дается нужный Ip адресс

Важные особенности:
1. Иерархическая структура:
Дерево: корень (.) → TLD (.com) → домен (example) → поддомен (www).

2. Распределённость:
Нет единой точки отказа. Данные хранятся на тысячах серверов.

3. Протокол и порт:
Работает поверх UDP (порт 53) для запросов, но использует TCP (порт 53) для больших ответов или трансферов зон.

4. DNSSEC:
Расширение для защиты от подмены ответов (цифровая подпись записей).


### API / REST API

**API (Application Programming Interface)** - проще говоря это набор правил и договоренностей которые позволяют приложениям взаимодейстовать друг с другом.

_Простой пример_ - Ты приходишь в ресторан как пользоавтлеь , перед тобой меню это разные команды , данные команды ты передаешь официанту, то есть API он передает их приложению которое возвращает тебе ответ в виде готового блюда

API - это посредник между сервером и пользователем.

**REST(Representational State Transfer)  API** - в свою очередь уже отностится не к протоколам ,а является архитектурным стилем. То есть некоторым набором правил, которым следует предерживать при реализации API  

**Основные принципы:**

1. Единообразие интерфейса 
Все данные представляются как ресурсы, каждый ресурс имеет уникальный индификатор.

_HTTP методы_ Действия с ресурсами как правило определяются основными методами, такими как:
* GET

* POST

* PUT/PATCH

* DELETE

Сами ресурсы и его представления это разные вещи, изначально они все являются JSON/XML файлами и сервер отправляет клиенту
представление ресурса, а клиент может его модефицировать и отправить обратно 

2. Отсутствие состояния (Stateless) 
Каждый запрос должен содержать всю необходимою информацию для понимания сообщения и что 
с ним нужно сделать, поскольку машина не хранит состояние между сессиями. 
Это сделано для упрощения масштабирования

3. Кэшируемость (Cacheable) 
Ответы сервера должны явно указывать можно ли кешировать данные и 
как долго. Это помогает повысить произваодительность

P.S. Это про то, нужно ли складывать данные в кеш, могут ли они использоваться еще раз и как часто.


4. Клиент-серверная архитектура 
Клиент ответчает за UI и пользовательский опыт. Сервер отвечает за хранение баз данных, бизнес логику и безопасность

5. Слоистая система (Layered System) 
Клиент не обязан знать с каким именно сервером он общается (основным, промежутончым и тд.)

#### Преимущества REST API

* Простота и понятность 
в связи с использованием HTTP-методов

* Гибкость 
Потому что можно использовать с любыми серверми которые понимают HTTP

* Масштабируемость 
Потому что используется метод отсутствия состояний

## Приложения 

### Git

**Git** - Система версионирования(конртоля версий), помогающая разработчкикам сохранять, обновлять и редактировать код.

Git как правило система которая позволяет удаленно, без интернета работать с кодом и передавть при необходимости в базу(тут я 
пытаюсь раскрыть такую мысль что, кодовая база, проект может храниться как у вас так и в удаленном репозитории)

Немного сленга :

_*сommit*_ - это некий слепок, фотка проекта в определенном его состоянии. 

Как пользоваться Git я уже писал, в этом репозитории , если будут вопросы или проблемы доделаю 

https://github.com/Nikitos-Naston/PR1_git

### Postgres

#### Язык SQL 

**Анатомия выполения SQL запросов**
1. From - откуда
2. Where - условия фильрации
3. Group By - группировка
4. Having - условие для групп
5. Select - что выбрать
6. Order by -  сортировка 
7. Limit -  ограниченне количетсво 

Запрос **Explain** - запрос который показывает как будет работать ваш запрос и есть **EXPLIN ANALYZE**  - показывает
время выполенения запроса и его план 
На что нужно обращать **ВНИМАНИЕ**:
* Seq scan
* Execution time > 100ms
* Rows Removed by filter(много строк убрано фильтром)

Варианты поиска:
IndexScan - Поиск по индексу
SecScan - последовательный поиск (стоит задуматься)
Index Only Scan - Только из индекса, без обращения к таблице(очень круто)

Index:
Система позволяющая отсортировать данные для быстрого доступа

Как понять что с базой данных что то не так?    
- Медленная загрузка
- Большая нагрузка на CPU и память
- Долгий timeout на подключение к БД

Для поиска медленных запросов можно использоавть pg_stat пример
``` SQL
SELECT
query,
mean_exec_time,
calls,
total_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 5;
```

Золотые правила:
1. Мониторьте использование: удаляйте неиспользуемые индексы
2. Тестируйте на продакшен-данных: маленькие таблицы обманчивы
3. Баланс чтения/записи: больше читаете = больше индексов можно

Фундаментальные свойства Баз Данных ACID:

1. Atomicity (Атомарность)
Нет частичного выполенения транзакции. Операция либо выполняется полностью либо не 
выполняется вообще

2. Consistency(Согласованность)
Соблюдение всех ограниченний ценности. БД переходит из одного валидного состояния в другое.

3. Isolation(Изолированность)
Каждая транзакция видит согласованное состояние данных. параллельные транзакции не влияют друг на друга

4. Durability(долговечность)
Устойчивость к сбоям системы. Зафиксиованные изменения сохраняются навсегда

Уровни изоляции 
Read Uncommitted
Максимальная скорость
Минимальная защита

Read Committed
I Золотая середина
Рекомендуется

Repeatable Read
В Высокая защита
Снижение
производительности

Serializable
Максимальная защита
Минимальная скорость

Deadlock
Для того чтобы избежать проблему DeadLockов, по хорошему установить порядок использоавния ресурсами, то есть если
транзакция A берет ресурс A и B, то транзакции B нужно сначала получить ресурс A, а потом уже работаь с другими ресурсами

Логирование - друг

Нормализация 
- Данные разбиты по таблицам
- Нет дубликатов
- Много операции JOIN для получения данных
- Идеально для транзакционных ситсем

Денормализация
- Данные дублируются
- меньше операции JOIN
- Быстрые Select запросы 
- Сложность поддержания консетености

Как Денормолизовать ? Можно сразу хранить вычесленное значения, часто использованные данные хранить в таблице 

Основной смысл работы с Postgres Это или использование PGadmin или, черзе подлкючение к psql через командную строку
### Kafka
https://www.youtube.com/watch?v=r2QiU0o5kWs
https://www.youtube.com/watch?v=UNOkvk_fMmM
https://www.youtube.com/@ListenIT_channel
### Reddis
https://www.youtube.com/watch?v=QpBaA6B1U90&list=WL&index=7&pp=gAQBiAQB
### Kubernetes
https://www.youtube.com/watch?v=2yoRWrc0MA0
### ClickHouse

### Docker 

**Docker** - платформа для разработки, доставки и запуска приложений в изоллированных средах, назывемые контейнерами

Если грубо говорить. Docker позволяет собирать приложения которые так собраны что части необохдиом запускать на разных платоформах с разной ОС или без этого никуда, приложение поддерживается только с использованием определенных библиотеках.

Можно сказать что докер это как маленькая виртуальная машина, которая легче и проще

**Основные концепции**

1. Docker Image(Образ)
    Шаблон с инструкциями для создание контейнера. Что и какие образы должно находится. Похож на класс

2. Docker Container 
    Запущенный процесс/приложение.

3. Docker File
    файл в котором рассказывается как правильно собирать контейнр. Рецепт 

4. Docker Compose
    Инструмент который позволяет собирать приложение из нескольких контенйров. Для этого все необходиомое опписывется в файле
    docker-compose.yml

**Интересные особенности**

1. Многоступенчатая сборка, позволяет сдлеать итоговой образ меньше по весу. 
Делается это благодрая использованием нескольих  этапов FROM 

2. Volumes(Тома)
    Специальный механизм который встраивается в контейнер и позволяет хранить данные.
    Поскольку в обычном режим данные в контейнере не хранятся

3. Docker networks
    Docker создают изоллированые сети с помощью которой общаются контейнеры

4. Docker ignore
    Файл в котором описываются игнорированные файлы для ускорения сборки.

**Основные команды**

docker pull nginx:alpine — скачать образ из реестра.

docker images — посмотреть список образов на машине.

docker rmi <image_id> — удалить образ.

docker run -p 8080:80 -d nginx:alpine — запустить контейнер в фоне (-d), пробросив порт хоста 8080 на порт контейнера 80.

docker ps — показать запущенные контейнеры.

docker ps -a — показать все контейнеры (в т.ч. остановленные).

docker stop <container_id> — gracefully остановить контейнер.

docker rm <container_id> — удалить остановленный контейнер.

docker exec -it <container_id> /bin/sh — войти в запущенный контейнер в интерактивном режиме (ключевые флаги -it).

Основные инструкции:

**FROM** — задает базовый образ. Всегда должна быть первой. Лучше использовать официальные и минималистичные образы (-alpine, -slim).

**RUN** — выполняет команду во время сборки образа (установка пакетов, компиляция).

**COPY / ADD** — копируют файлы с хоста в образ. ADD умеет также распаковывать архивы и скачивать файлы по URL, но для простоты копирования рекомендуется использовать COPY.

**WORKDIR** — задает рабочую директорию для всех последующих инструкций (аналог cd).

**EXPOSE** — указывает, какой порт слушает приложение. Это документирование, а не проброс порта. Проброс делается командой -p в docker run.

**ENV** — устанавливает environment variables, которые будут доступны и при сборке, и в запущенном контейнере.

**CMD** — задает команду по умолчанию для запуска процесса внутри контейнера. Аргументы CMD можно переопределить при запуске контейнера. В Dockerfile может быть только одна инструкция CMD.


## Язык GO

#### ООП 

### Структура файла в языках GO
my-go-app/
├── cmd/
│   └── api/
│       └── main.go          # Точка входа (инициализация, запуск сервера)
├── internal/                # Приватный код вашего проекта (нельзя импортировать извне)
│   ├── entity/              # Сущности предметной области (User, Post)
│   │   └── user.go
│   ├── transport/           # HTTP-обработчики, роутинг
│   │   └── http/
│   │       └── v1/
│   │           └── user_handler.go
│   ├── service/             # Бизнес-логика (use cases)
│   │   └── user_service.go
│   └── repository/          # Работа с данными (БД, кэш, API)
│       └── user_repository.go
├── pkg/                     # Публичный код, который можно использовать в других проектах
│   └── utils/
│       └── stringutils.go
├── configs/                 # Конфигурационные файлы
├── migrations/              # SQL-миграции схемы БД
├── Dockerfile
├── go.mod
└── go.sum



